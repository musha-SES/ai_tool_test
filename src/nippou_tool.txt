/**
 * スプレッドシートを開いたときにカスタムメニューを追加する関数。
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('日報AIツール')
    .addItem('日報質問送信（Chatwork）', 'sendDailyReportQuestions')
    .addItem('Chatwork日報取得・分析', 'processChatworkReplies')
    .addSeparator()
    .addItem('定期実行トリガーを設定', 'createDailyTriggers')
    .addItem('全てのトリガーを削除', 'deleteTriggers')
    .addSeparator()
    .addItem('自己評価シート分析', 'processSelfEvaluationSheets')
    .addSeparator()
    .addItem('1on1ヒアリング項目生成', 'generate1on1Topics')
    .addToUi();
}

// --- トリガー管理機能 ---

/**
 * スクリプトプロパティから定期実行の時刻を取得する。
 * @returns {{questionHour: number, questionMinute: number, replyHour: number, replyMinute: number}}
 */
function getScheduledTimes() {
  const properties = PropertiesService.getScriptProperties();
  const defaults = {
    questionHour: 9,
    questionMinute: 0,
    replyHour: 18,
    replyMinute: 0
  };

  const getPropertyAsInt = (key, defaultValue) => {
    const prop = properties.getProperty(key);
    const value = parseInt(prop, 10);
    if (isNaN(value)) {
      Logger.log(`スクリプトプロパティ「${key}」が未設定または不正です。デフォルト値 (${defaultValue}) を使用します。`);
      return defaultValue;
    }
    return value;
  };

  const questionHour = getPropertyAsInt('DAILY_QUESTION_TIME_HOUR', defaults.questionHour);
  const questionMinute = getPropertyAsInt('DAILY_QUESTION_TIME_MINUTE', defaults.questionMinute);
  const replyHour = getPropertyAsInt('DAILY_REPLY_COLLECT_TIME_HOUR', defaults.replyHour);
  const replyMinute = getPropertyAsInt('DAILY_REPLY_COLLECT_TIME_MINUTE', defaults.replyMinute);

  return { questionHour, questionMinute, replyHour, replyMinute };
}

/**
 * 毎日の定期実行トリガーを作成する。
 */
function createDailyTriggers() {
  // 既存のトリガーを一旦すべて削除
  deleteTriggers();

  const { questionHour, questionMinute, replyHour, replyMinute } = getScheduledTimes();

  // 質問送信トリガー
  ScriptApp.newTrigger('sendDailyReportQuestions')
    .timeBased()
    .everyDays(1)
    .atHour(questionHour)
    .nearMinute(questionMinute) // atMinuteの代わりにnearMinuteで柔軟性を持たせる
    .create();
  Logger.log(`日報質問送信トリガーを毎日 ${questionHour}時${questionMinute}分頃に設定しました。`);

  // 返信収集トリガー
  ScriptApp.newTrigger('processChatworkReplies')
    .timeBased()
    .everyDays(1)
    .atHour(replyHour)
    .nearMinute(replyMinute)
    .create();
  Logger.log(`Chatwork日報取得・分析トリガーを毎日 ${replyHour}時${replyMinute}分頃に設定しました。`);

  // クリーンアップトリガー（毎週月曜日深夜）
  ScriptApp.newTrigger('cleanUpBotQuestionLog')
    .timeBased()
    .everyWeeks(1) // 毎週
    .onWeekDay(ScriptApp.WeekDay.MONDAY) // 月曜日
    .atHour(2) // 深夜2時
    .create();
  Logger.log(`BOT質問ログクリーンアップトリガーを毎週月曜日深夜2時に設定しました。`);

  SpreadsheetApp.getUi().alert('定期実行トリガーを設定しました。 質問送信: 毎日' + `${questionHour}時${questionMinute}分頃` + ' 返信収集: 毎日' + `${replyHour}時${replyMinute}分頃` + ' ログクリーンアップ: 毎週月曜日深夜');
}

/**
 * BOT質問ログシートをクリーンアップする。
 * - 「返信済み_処理成功」のレコードを削除。
 * - 古い「未返信」レコード（7日以上前）を削除。
 * - 古いエラー/フォーマット不正レコード（7日以上前）を削除。
 */
function cleanUpBotQuestionLog() {
  const logSheetName = 'BOT質問ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。クリーンアップをスキップします。`);
    return;
  }

  const range = sheet.getDataRange();
  const values = range.getValues();
  if (values.length <= 1) { // ヘッダー行のみの場合
    Logger.log('BOT質問ログシートにデータがありません。クリーンアップをスキップします。');
    return;
  }

  const rowsToDelete = [];
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

  for (let i = 1; i < values.length; i++) { // ヘッダー行をスキップ
    const row = values[i];
    const status = row[3].toString(); // ステータス列 (D列)
    const timestamp = new Date(row[2]); // 送信日時列 (C列)

    if (status === '返信済み_処理成功') {
      rowsToDelete.push(i + 1); // 行番号を記録
    } else if (status === '未返信' && timestamp < sevenDaysAgo) {
      rowsToDelete.push(i + 1);
    } else if ((status === '返信済み_フォーマット不正' || status.startsWith('エラー発生')) && timestamp < sevenDaysAgo) {
      rowsToDelete.push(i + 1);
    }
  }

  // 行番号が大きい方から削除していく（インデックスがずれないようにするため）
  rowsToDelete.sort((a, b) => b - a);
  for (const rowIndex of rowsToDelete) {
    sheet.deleteRow(rowIndex);
  }
  Logger.log(`BOT質問ログシートのクリーンアップが完了しました。${rowsToDelete.length}件のレコードを削除しました。`);
}

/**
 * このスクリプトで設定されたすべてのトリガーを削除する。
 */
function deleteTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  for (const trigger of triggers) {
    ScriptApp.deleteTrigger(trigger);
  }
  Logger.log('すべてのトリガーを削除しました。');
}



// --- Chatwork連携機能 ---

/**
 * Chatwork APIキーをスクリプトプロパティから取得する。
 * @returns {string} Chatwork APIキー
 * @throws {Error} APIキーが設定されていない場合
 */
function getChatworkApiKey() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('CHATWORK_API_KEY');
  if (!apiKey) {
    throw new Error('Chatwork API Key is not set in Script Properties.');
  }
  return apiKey;
}

/**
 * Chatworkの対象ルームIDをスクリプトプロパティから取得する。
 * @returns {Object} 氏名をキー、ルームIDを値とするオブジェクト
 * @throws {Error} ルームIDが設定されていない場合
 */
function getChatworkTargetRoomIds() {
  const roomIdsStr = PropertiesService.getScriptProperties().getProperty('CHATWORK_ROOM_IDS');
  if (!roomIdsStr) {
    throw new Error('Chatwork Room IDs are not set in Script Properties.');
  }
  try {
    return JSON.parse(roomIdsStr);
  } catch (e) {
    throw new Error('Failed to parse Chatwork Room IDs. Please ensure it is a valid JSON string like: {"manager": "12345", "user1": "67890"}');
  }
}

/**
 * 全ての部下に日報提出を促す質問をChatworkで送信する。
 */
function sendDailyReportQuestions() {
  const roomIds = getChatworkTargetRoomIds();
  const managerName = "manager"; // マネージャーのキー名は固定
  const pendingQuestions = getPendingQuestionMessages(); // 未処理の質問メッセージIDを取得

  for (const name in roomIds) {
    if (name !== managerName) {
      const roomId = roomIds[name];

      // 未処理またはロック状態の日報が存在するかチェック
      const existingPending = pendingQuestions.find(q => 
        q.roomId === roomId && 
        (q.status === '未返信' || q.status === '返信済み_フォーマット不正' || q.status.startsWith('エラー発生'))
      );

      if (existingPending) {
        Logger.log(`${name}さん（ルームID: ${roomId}）には未処理またはロック状態の日報が存在するため、質問送信をスキップしました。ステータス: ${existingPending.status}`);
        continue; // 次のルームへ
      }

      const message = `[To:${roomId}] ${name}さん\nおはようございます！\n本日の日報を以下のフォーマットでご返信ください。\n\n#日報\n業務内容：\n気分：(良い/普通/悪い)\n困っていること：`;
      try {
        const response = sendChatworkNotification(roomId, message);
        const messageId = response.message_id.toString();
        logQuestionMessageId(roomId, messageId, new Date(), '未返信'); // 初期ステータスを「未返信」で記録
        Logger.log(`${name}さん (Room ID: ${roomId}) への質問送信に成功しました。メッセージID: ${messageId}`);
      } catch (e) {
        Logger.log(`${name}さん (Room ID: ${roomId}) への質問送信に失敗しました: ${e.message}`);
      }
    }
  }
}

/**
 * Chatworkの返信を収集し、日報として解析・評価する。
 */
function processChatworkReplies() {
  const roomIds = getChatworkTargetRoomIds();
  const managerName = "manager";
  const botAccountId = getBotChatworkAccountId(); // BOT自身のアカウントIDを取得
  const pendingQuestions = getPendingQuestionMessages(); // 未処理の質問メッセージIDを取得

  for (const name in roomIds) {
    if (name !== managerName) {
      const roomId = roomIds[name];
      
      // このルームIDに対する未処理（未返信、エラー、フォーマット不正）の質問メッセージIDをフィルタリング
      const questionsForThisRoom = pendingQuestions.filter(q => 
        q.roomId === roomId && 
        q.status !== '返信済み_処理成功'
      );

      if (questionsForThisRoom.length === 0) {
        Logger.log(`${name}さん (Room ID: ${roomId}) に対する未処理の質問メッセージが見つかりませんでした。`);
        continue; // 次のルームへ
      }

      // ロック状態の質問をスキップ
      const lockedQuestion = questionsForThisRoom.find(q => 
        q.status === '返信済み_フォーマット不正' || 
        q.status.startsWith('エラー発生')
      );
      if (lockedQuestion) {
        Logger.log(`${name}さん (Room ID: ${roomId}) の日報はロックステータス（${lockedQuestion.status}）のためスキップしました。`);
        continue; // 次のルームへ
      }

      try {
        const messages = getChatworkMessages(roomId, 50); // 直近50件のメッセージを取得（返信を探すため多めに）

        let processedThisRoom = false;
        for (let i = messages.length - 1; i >= 0; i--) { // 最新のメッセージから遡る
          const msg = messages[i];

          // BOT自身が送信したメッセージはスキップ
          if (msg.account_id && msg.account_id.toString() === botAccountId) {
            continue;
          }

          // 引用形式の返信メッセージかチェック
          const replyMatch = msg.body.match(/\[rp aid=(\d+) to=(\d+)-(\d+)\]/);
          if (replyMatch) {
            const repliedToMessageId = replyMatch[3]; // 返信元のメッセージID

            // この返信が、BOTが送信した質問メッセージへの返信かチェック
            const matchedQuestion = questionsForThisRoom.find(q => q.messageId === repliedToMessageId);

            if (matchedQuestion) {
              // 日報フォーマットのチェック
              if (msg.body.includes('#日報')) { // #日報ハッシュタグがあれば解析を試みる
                const reportData = parseReportFromMessage(name, msg.body);
                Logger.log(`--- Chatworkから日報データ抽出 (${name}) ---`);
                Logger.log(JSON.stringify(reportData, null, 2));
                Logger.log('------------------------------------');

                const validationResult = validateDailyReport(reportData);
                if (validationResult.isValid) {
                  try {
                    assessAndNotify(reportData);
                    updateQuestionStatus(roomId, matchedQuestion.messageId, '返信済み_処理成功'); // 処理成功
                  } catch (e) {
                    Logger.log(`日報処理中にエラーが発生しました: ${e.message}`);
                    updateQuestionStatus(roomId, matchedQuestion.messageId, 'エラー発生_その他', e.message); // その他エラー
                  }
                } else {
                  Logger.log(`${name}さんの日報はフォーマット不正/不完全なためスキップしました。詳細: ${validationResult.message}`);
                  updateQuestionStatus(roomId, matchedQuestion.messageId, '返信済み_フォーマット不正', validationResult.message); // フォーマット不正
                }
              } else {
                Logger.log(`${name}さんのメッセージ (ID: ${msg.message_id}) は質問への返信ですが、日報フォーマットではありませんでした。スキップします。`);
                // 日報フォーマットではないが、質問への返信なので、ステータスは更新しない（再提出を促すため）
              }
              processedThisRoom = true; // 質問への返信が見つかったので、このルームの処理は完了
              break; // このルームのメッセージループを抜ける
            }
          }
        }
        if (!processedThisRoom) {
          Logger.log(`${name}さん (Room ID: ${roomId}) の日報返信が見つかりませんでした、または未処理の質問メッセージへの有効な返信ではありませんでした。`);
        }
      } catch (e) {
        Logger.log(`${name}さん (Room ID: ${roomId}) のメッセージ処理中にエラーが発生しました: ${e.message}`);
        // ルーム全体のメッセージ取得エラーなど、特定の質問に紐づかないエラー
        // この場合、どの質問メッセージIDに紐づけるか判断できないため、ログのみ
      }
    }
  }
}

/**
 * Chatwork APIを呼び出してメッセージを取得する。
 * @param {string} roomId ルームID
 * @param {number} count 取得するメッセージ数
 * @returns {Array} メッセージオブジェクトの配列
 */
function getChatworkMessages(roomId, count) {
  const apiKey = getChatworkApiKey();
  const url = `https://api.chatwork.com/v2/rooms/${roomId}/messages?force=1`;
  
  const options = {
    method: 'get',
    headers: { 'X-ChatWorkToken': apiKey },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const responseText = response.getContentText();

  if (responseCode === 200) {
    return JSON.parse(responseText).slice(-count); // 最新のメッセージを返す
  } else {
    throw new Error(`Chatwork APIからのメッセージ取得に失敗しました。Status: ${responseCode}, Response: ${responseText}`);
  }
}

/**
 * メッセージの中から最新の日報返信を探す。
 * @param {Array} messages メッセージオブジェクトの配列
 * @returns {Object|null} 日報返信メッセージオブジェクト or null
 */
function findLatestDailyReportReply(messages) {
    // 簡易的にキーワードを含む最新のメッセージを返信とみなす
    for (let i = messages.length - 1; i >= 0; i--) {
        const msg = messages[i].body;
        if (msg.includes('#日報') && msg.includes('業務内容：') && msg.includes('気分：') && msg.includes('困っていること：')) {
            return messages[i];
        }
    }
    return null;
}

/**
 * Chatworkメッセージから日報データを抽出する。
 * @param {string} name 氏名
 * @param {string} messageBody メッセージ本文
 * @returns {Object} 日報データオブジェクト
 */
function parseReportFromMessage(name, messageBody) {
  // 各項目を柔軟に抽出するための正規表現
  // コロンの後に任意の空白文字（スペース、改行など）が0回以上続くことを許容
  // 次の項目、または文字列の末尾までを内容として抽出
  const workContentMatch = messageBody.match(/業務内容：\s*([\s\S]*?)(?=\n*気分：|\n*困っていること：|$)/);
  const moodMatch = messageBody.match(/気分：\s*([\s\S]*?)(?=\n*困っていること：|$)/);
  const problemsMatch = messageBody.match(/困っていること：\s*([\s\S]*)/);

  return {
    date: new Date().toLocaleString('ja-JP'),
    name: name,
    workContent: workContentMatch ? workContentMatch[1].trim() : 'N/A',
    mood: moodMatch ? moodMatch[1].trim() : 'N/A',
    problems: problemsMatch ? problemsMatch[1].trim() : '特になし'
  };
}

/**
 * 日報データのバリデーションを行う。
 * @param {Object} reportData 日報データオブジェクト
 * @returns {{isValid: boolean, message: string}} バリデーション結果とメッセージ
 */
function validateDailyReport(reportData) {
  const moods = ['良い', '普通', '悪い'];

  if (!reportData.name || reportData.name.trim() === 'N/A' || reportData.name.trim() === '') {
    return { isValid: false, message: '氏名が空です。' };
  }
  if (!reportData.workContent || reportData.workContent.trim() === 'N/A' || reportData.workContent.trim() === '') {
    return { isValid: false, message: '業務内容が空です。' };
  }
  // 気分のバリデーションを強化
  if (!reportData.mood || reportData.mood.trim() === 'N/A' || !moods.includes(reportData.mood.trim())) {
    return { isValid: false, message: `気分に不正な値が入力されています。「${reportData.mood}」。有効な値は「良い」「普通」「悪い」です。` };
  }
  // problemsは任意項目なのでバリデーションしない

  return { isValid: true, message: '' };
}


// --- Gemini API & 通知機能 ---

/**
 * 日報データを評価し、必要に応じて通知する。
 * @param {Object} reportData 日報データ
 */
function assessAndNotify(reportData) {
  const geminiPrompt = `以下の日報の内容を分析し、提出者の現在の心理状態や業務の調子について、5段階（非常に良い、良い、普通、少し悪い、危険）で評価してください。\n**特に「今日の気分」が悪い場合や、「困っていること」にネガティブな兆候が見られる場合は「危険」と判断し、その理由も簡潔に述べてください。**\n氏名は匿名化し、「提出者」として言及してください。\n\n業務内容：${reportData.workContent}\n気分：${reportData.mood}\n困っていること：${reportData.problems}\n\n結果はJSON形式で返してください。例: { "status": "危険", "reason": "具体例：今日の気分が悪いと申告しており、困っている内容にXXとあるため。" }`;

  let geminiStatus = '不明';
  let geminiReason = 'Gemini APIからの応答がありませんでした。';

  try {
    const geminiResponse = callGeminiApi(geminiPrompt);
    let rawGeminiText = geminiResponse.candidates[0].content.parts[0].text;
    
    const jsonMatch = rawGeminiText.match(/\{([\s\S]*?)\}/);
    
    if (jsonMatch && jsonMatch[0]) {
      const jsonString = jsonMatch[0];
      const parsedResponse = JSON.parse(jsonString);
      geminiStatus = parsedResponse.status;
      geminiReason = parsedResponse.reason;
    } else {
      throw new Error('Gemini API response did not contain a valid JSON object.');
    }

    Logger.log(`Gemini AIによる評価: 状態 - ${geminiStatus}, 理由 - ${geminiReason}`);

  } catch (error) {
    Logger.log('Gemini API呼び出しまたは応答解析に失敗しました: ' + error.message + '. Gemini APIキーの有効性、またはAPIの応答形式を確認してください。');
  }

  if (geminiStatus === '危険' || geminiStatus === '少し悪い') {
    const roomIds = getChatworkTargetRoomIds();
    const managerRoomId = roomIds.manager;

    if (!managerRoomId) {
        Logger.log("マネージャーのChatworkルームIDが設定されていません。通知をスキップします。");
        return;
    }

    const subject = `【注意】日報から社員の調子に懸念 - ${reportData.name}`;
    const body = `[info]\n` +
                 `[title]${subject}[/title]\n` +
                 `提出者：${reportData.name}\n` +
                 `日付：${reportData.date}\n` +
                 `Gemini AIによる評価：${geminiStatus}\n` +
                 `理由：${geminiReason}\n` +
                 `[hr]\n` +
                 `▼ 日報抜粋\n` +
                 `今日の気分：${reportData.mood}\n` +
                 `困っていること：${reportData.problems}\n` +
                 `[hr]\n` +
                 `詳細については、スプレッドシートをご確認ください。\n` +
                 `[/info]`;
    try {
      sendChatworkNotification(managerRoomId, body);
      Logger.log('Chatworkへの注意通知が正常に送信されました。');
    } catch (e) {
      Logger.log('Chatworkへの注意通知の送信に失敗しました: ' + e.message);
      // Chatwork通知自体が失敗した場合、マネージャーへの通知はできないためログのみ
      Logger.log('Chatworkへの注意通知の送信に失敗しました。Chatwork APIキーまたはルームIDを確認してください。');
    }
  } else {
    Logger.log(`社員の調子は「${geminiStatus}」と判断されました。Chatwork通知は行いません。`);
  }

  // スプレッドシートへのログ記録
  try {
    logReportToSheet(reportData, geminiStatus, geminiReason);
  } catch (e) {
    Logger.log('スプレッドシートへの日報ログ記録に失敗しました: ' + e.message + '. 「日報ログ」シートが存在するか、アクセス権限を確認してください。');
  }
}

/**
 * 日報データをスプレッドシートに記録する。
 * @param {Object} reportData 日報データ
 * @param {string} status AIによる評価状態
 * @param {string} reason AIによる評価理由
 */
function logReportToSheet(reportData, status, reason) {
  const logSheetName = '日報ログ';
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
    if (!sheet) {
      throw new Error(`シート「${logSheetName}」が見つかりません。`);
    }

    const logData = [
      new Date(), // タイムスタンプ
      reportData.name,
      reportData.date,
      reportData.workContent,
      reportData.mood,
      reportData.problems,
      status,
      reason
    ];

    sheet.appendRow(logData);
    Logger.log(`日報データを「${logSheetName}」シートに記録しました。`);
  } catch (e) {
    // ここでのエラーはassessAndNotifyでキャッチされ、マネージャーに通知される
    throw e; // 再スローしてassessAndNotifyで処理させる
  }
}

/**
 * Chatworkにメッセージを送信する汎用関数。
 * @param {string} roomId 送信先のルームID
 * @param {string} message 送信するメッセージ本文
 * @returns {Object} Chatwork APIからのレスポンスオブジェクト
 */
function sendChatworkNotification(roomId, message) {
  try {
    const apiKey = getChatworkApiKey();
    const url = `https://api.chatwork.com/v2/rooms/${roomId}/messages`;

    const payload = {
      body: message,
      self_unread: 1 // 自分にも未読にする
    };

    const options = {
      method: 'post',
      headers: { 'X-ChatWorkToken': apiKey },
      contentType: 'application/x-www-form-urlencoded',
      payload: Object.keys(payload).map(key => `${key}=${encodeURIComponent(payload[key])}`).join('&'),
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();

    if (responseCode !== 200) {
      throw new Error(`Chatwork APIへのメッセージ送信に失敗しました。Status: ${responseCode}, Response: ${responseText}`);
    }
    return JSON.parse(responseText); // レスポンス全体を返す
  } catch (e) {
    // sendChatworkNotification自体が失敗した場合、これ以上Chatworkで通知はできないため、ログのみ
    Logger.log(`sendChatworkNotificationでエラーが発生しました: ${e.message}`);
    throw e; // 呼び出し元で処理させる
  }
}

const CHATWORK_BOT_ACCOUNT_ID_KEY = 'CHATWORK_BOT_ACCOUNT_ID';

/**
 * BOT自身（APIトークン所有者）のChatworkアカウントIDを取得する。
 * スクリプトプロパティに保存されていればそこから読み込み、なければAPIを呼び出して保存する。
 * @returns {string} BOTのChatworkアカウントID
 */
function getBotChatworkAccountId() {
  const properties = PropertiesService.getScriptProperties();
  let botAccountId = properties.getProperty(CHATWORK_BOT_ACCOUNT_ID_KEY);

  if (botAccountId) {
    Logger.log(`スクリプトプロパティからBOTアカウントIDを取得しました: ${botAccountId}`);
    return botAccountId;
  }

  Logger.log('スクリプトプロパティにBOTアカウントIDが見つかりませんでした。Chatwork APIから取得します。');
  try {
    const apiKey = getChatworkApiKey();
    const url = 'https://api.chatwork.com/v2/me';
    const options = {
      method: 'get',
      headers: { 'X-ChatWorkToken': apiKey },
      muteHttpExceptions: true
    };
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    if (responseCode !== 200) {
      throw new Error(`Chatwork API (me) からアカウントIDの取得に失敗しました。Status: ${responseCode}, Response: ${response.getContentText()}`);
    }
    const me = JSON.parse(response.getContentText());
    botAccountId = me.account_id.toString();
    setChatworkBotAccountId(botAccountId); // 取得したIDをスクリプトプロパティに保存
    Logger.log(`Chatwork APIからBOTアカウントIDを取得し、スクリプトプロパティに保存しました: ${botAccountId}`);
    return botAccountId;
  } catch (e) {
    Logger.log(`BOTアカウントIDの取得に失敗しました: ${e.message}. Chatwork APIキーが有効か、またはChatwork APIにアクセスできるか確認してください。`);
    throw e; // 呼び出し元で処理させる
  }
}

/**
 * BOTアカウントIDをスクリプトプロパティに保存する。
 * @param {string} accountId 保存するアカウントID
 */
function setChatworkBotAccountId(accountId) {
  PropertiesService.getScriptProperties().setProperty(CHATWORK_BOT_ACCOUNT_ID_KEY, accountId);
  Logger.log(`BOTアカウントID ${accountId} をスクリプトプロパティに保存しました。`);
}

/**
 * 送信した質問メッセージのIDをBOT質問ログシートに記録する。
 * @param {string} roomId 質問を送信したルームID
 * @param {string} messageId 送信された質問メッセージのID
 * @param {Date} timestamp 送信日時
 * @param {string} status 初期ステータス
 */
function logQuestionMessageId(roomId, messageId, timestamp, status) {
  const logSheetName = 'BOT質問ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    throw new Error(`シート「${logSheetName}」が見つかりません。`);
  }
  sheet.appendRow([roomId, messageId, timestamp, status, '']);
  Logger.log(`質問メッセージID ${messageId} をルーム ${roomId} に記録しました。ステータス: ${status}`);
}

/**
 * BOT質問ログシートから未処理の質問メッセージIDを読み込む。
 * @returns {Array<Object>} 未処理の質問メッセージオブジェクトの配列
 */
function getPendingQuestionMessages() {
  const logSheetName = 'BOT質問ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。未処理の質問メッセージはありません。`);
    return [];
  }
  const range = sheet.getDataRange();
  const values = range.getValues();
  if (values.length <= 1) { // ヘッダー行のみの場合
    return [];
  }
  const pendingQuestions = [];
  for (let i = 1; i < values.length; i++) {
    pendingQuestions.push({
      rowIndex: i + 1, // スプレッドシートの行番号
      roomId: values[i][0].toString(),
      messageId: values[i][1].toString(),
      timestamp: new Date(values[i][2]),
      status: values[i][3].toString(),
      errorDetail: values[i][4] ? values[i][4].toString() : ''
    });
  }
  return pendingQuestions;
}

/**
 * BOT質問ログシートの質問メッセージのステータスを更新する。
 * @param {string} roomId 対象のルームID
 * @param {string} messageId 対象のメッセージID
 * @param {string} newStatus 更新後のステータス
 * @param {string} [errorDetail=''] エラー詳細（エラー発生時のみ）
 */
function updateQuestionStatus(roomId, messageId, newStatus, errorDetail = '') {
  const logSheetName = 'BOT質問ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。ステータス更新はできませんでした。`);
    return;
  }
  const range = sheet.getDataRange();
  const values = range.getValues();
  for (let i = 1; i < values.length; i++) { // ヘッダー行をスキップ
    if (values[i][0].toString() === roomId && values[i][1].toString() === messageId) {
      sheet.getRange(i + 1, 4).setValue(newStatus); // ステータス列 (D列)
      sheet.getRange(i + 1, 5).setValue(errorDetail); // エラー詳細列 (E列)
      Logger.log(`質問メッセージID ${messageId} のステータスを ${newStatus} に更新しました。`);
      return;
    }
  }
  Logger.log(`質問メッセージID ${messageId} をルーム ${roomId} から見つけられませんでした。ステータス更新失敗。`);
}


/**
 * Gemini APIキーをスクリプトプロパティから取得する。
 * @returns {string} Gemini APIキー
 */
function getGeminiApiKey() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  if (!apiKey) {
    throw new Error('Gemini API Key is not set in Script Properties.');
  }
  return apiKey;
}

/**
 * Gemini APIを呼び出し、応答をJSON形式で返す。
 * @param {string} prompt Geminiに送信するプロンプト
 * @returns {Object} Geminiからの生のJSON応答オブジェクト
 */
function callGeminiApi(prompt) {
  try {
    const apiKey = getGeminiApiKey();
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

    const requestBody = {
      contents: [{ parts: [{ text: prompt }] }]
    };

    const options = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(requestBody),
      muteHttpExceptions: true,
    };

    Logger.log('Gemini APIに送信するプロンプト: ' + prompt);

    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();

    if (responseCode === 200) {
      try {
        return JSON.parse(responseText);
      } catch (e) {
        throw new Error('Gemini API returned invalid JSON: ' + responseText);
      }
    } else {
      throw new Error(`Gemini API呼び出しが失敗しました。HTTPステータスコード: ${responseCode}, 応答: ${responseText}`);
    }
  } catch (e) {
    // ここでのエラーはassessAndNotifyでキャッチされ、マネージャーに通知される
    throw e; // 再スローしてassessAndNotifyで処理させる
  }
}

// --- 自己評価シート分析機能 ---

/**
 * 自己評価シート（CSVファイル）が格納されているGoogleドライブのフォルダIDをスクリプトプロパティから取得する。
 * @returns {string} GoogleドライブのフォルダID
 * @throws {Error} フォルダIDが設定されていない場合
 */
function getSelfEvaluationFolderId() {
  const folderId = PropertiesService.getScriptProperties().getProperty('SELF_EVALUATION_FOLDER_ID');
  if (!folderId) {
    throw new Error('SELF_EVALUATION_FOLDER_ID is not set in Script Properties.');
  }
  return folderId;
}

/**
 * 自己評価シートの氏名列のヘッダー名をスクリプトプロパティから取得する。
 * @returns {string} 氏名列のヘッダー名
 */
function getSelfEvaluationNameColumnHeader() {
  const header = PropertiesService.getScriptProperties().getProperty('SELF_EVALUATION_NAME_COLUMN_HEADER');
  return header || '氏名'; // デフォルトは「氏名」
}



/**
 * 指定されたGoogleドライブフォルダ内の自己評価シート（Googleスプレッドシート）を読み込み、
 * その内容を匿名化してGeminiに分析させ、結果をChatworkで通知する。
 */
function processSelfEvaluationSheets() {
  const folderId = getSelfEvaluationFolderId();
  const nameColumnHeader = getSelfEvaluationNameColumnHeader();
  const roomIds = getChatworkTargetRoomIds();
  const managerRoomId = roomIds.manager;

  if (!managerRoomId) {
    Logger.log("マネージャーのChatworkルームIDが設定されていません。自己評価シート分析結果の通知をスキップします。");
    return;
  }

  try {
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.GOOGLE_SHEETS);

    if (!files.hasNext()) {
      Logger.log(`指定されたフォルダ（ID: ${folderId}）にGoogleスプレッドシートが見つかりませんでした。`);
      SpreadsheetApp.getUi().alert('自己評価シート分析', `指定されたフォルダにGoogleスプレッドシートが見つかりませんでした。`, SpreadsheetApp.getUi().ButtonSet.OK);
      return;
    }

    while (files.hasNext()) {
      const file = files.next();
      if (!file.getName().includes('自己評価')) {
        Logger.log(`ファイル名に「自己評価」を含まないためスキップ: ${file.getName()}`);
        continue;
      }

      Logger.log(`自己評価シートを処理中: ${file.getName()}`);
      
      let spreadsheet;
      try {
        spreadsheet = SpreadsheetApp.openById(file.getId());
      } catch (e) {
        Logger.log(`スプレッドシート「${file.getName()}」のオープンに失敗しました: ${e.message}`);
        continue;
      }

      const sheet = spreadsheet.getSheets()[0]; // 最初のシートを対象
      const data = sheet.getDataRange().getValues();

      if (data.length < 2) {
        Logger.log(`ヘッダー行のみ、またはデータがないためスキップ: ${file.getName()}`);
        continue;
      }

      const headers = data[0];
      const nameColumnIndex = headers.indexOf(nameColumnHeader);

      if (nameColumnIndex === -1) {
        Logger.log(`スプレッドシート「${file.getName()}」に氏名列（ヘッダー: ${nameColumnHeader}）が見つかりませんでした。スキップします。`);
        continue;
      }

      // ヘッダー行を除いたデータ行を処理
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const originalName = row[nameColumnIndex];
        const anonymousName = originalName ? `提出者_${i}` : '提出者'; // 匿名化
        
        let promptData = '';
        // 氏名列以外のデータをプロンプトに含める
        headers.forEach((header, index) => {
          if (index !== nameColumnIndex) {
            promptData += `${header}: ${row[index] || ''}\n`;
          }
        });

        const geminiPrompt = `以下の${anonymousName}さんの自己評価コメントを分析し、強み、改善点、今後の成長領域について簡潔にまとめてください。各項目とそのコメントを考慮してください。

自己評価データ：
${promptData}`;

        try {
          const geminiResponse = callGeminiApi(geminiPrompt);
          const analysisResult = geminiResponse.candidates[0].content.parts[0].text;

          const subject = `【自己評価シート分析結果】${anonymousName}さん向け`;
          const body = `[info]\n[title]${subject}[/title]\n${analysisResult}\n[/info]`;

          sendChatworkNotification(managerRoomId, body);
          Logger.log(`${anonymousName}さんの自己評価シート分析結果をChatworkに通知しました。`);

        } catch (error) {
          Logger.log(`Gemini API呼び出しまたはChatwork通知に失敗しました（${anonymousName}さん）: ${error.message}`);
        }
      }
    }
    SpreadsheetApp.getUi().alert('自己評価シート分析', '自己評価シートの分析と通知が完了しました。', SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    Logger.log(`自己評価シート処理中にエラーが発生しました: ${e.message}`);
    SpreadsheetApp.getUi().alert('エラー', `自己評価シート処理中にエラーが発生しました: ${e.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

// --- 1on1ヒアリング項目生成機能 ---

/**
 * 「日報ログ」シートから全社員の名前を取得する。
 * @returns {string[]} 社員名のユニークなリスト
 */
function getAllEmployeeNames() {
  const logSheetName = '日報ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。`);
    return [];
  }
  const range = sheet.getDataRange();
  const values = range.getValues();
  if (values.length <= 1) { // ヘッダー行のみの場合
    return [];
  }
  const names = new Set();
  for (let i = 1; i < values.length; i++) {
    names.add(values[i][1]); // 氏名列 (B列)
  }
  return Array.from(names);
}

/**
 * 指定された社員の過去の日報データを取得する。
 * @param {string} employeeName 社員名
 * @param {number} limit 取得する日報の件数（直近から）
 * @returns {Object[]} 日報データの配列
 */
function getDailyReportDataForEmployee(employeeName, limit = 5) {
  const logSheetName = '日報ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。`);
    return [];
  }
  const range = sheet.getDataRange();
  const values = range.getValues();
  if (values.length <= 1) {
    return [];
  }

  const employeeReports = [];
  for (let i = values.length - 1; i >= 1; i--) { // 最新の日報から遡る
    const row = values[i];
    if (row[1] === employeeName) { // 氏名列 (B列)
      employeeReports.push({
        aiStatus: row[6], // AI評価状態 (G列)
        aiReason: row[7] // AI評価理由 (H列)
      });
      if (employeeReports.length >= limit) {
        break;
      }
    }
  }
  return employeeReports.reverse(); // 古い順に戻す
}

/**
 * 指定された社員の自己評価シートデータを取得する。
 * @param {string} employeeName 社員名
 * @returns {Object|null} 自己評価シートデータ（オブジェクト形式）
 */
function getSelfEvaluationDataForEmployee(employeeName) {
  const folderId = getSelfEvaluationFolderId();
  const nameColumnHeader = getSelfEvaluationNameColumnHeader();

  try {
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.GOOGLE_SHEETS);

    while (files.hasNext()) {
      const file = files.next();
      // ファイル名に「自己評価」を含み、かつ社員名が含まれるファイルを検索
      if (file.getName().includes('自己評価') && file.getName().includes(employeeName)) {
        Logger.log(`自己評価シートを読み込み中: ${file.getName()}`);
        let spreadsheet;
        try {
          spreadsheet = SpreadsheetApp.openById(file.getId());
        } catch (e) {
          Logger.log(`スプレッドシート「${file.getName()}」のオープンに失敗しました: ${e.message}`);
          continue;
        }

        const sheet = spreadsheet.getSheets()[0]; // 最初のシートを対象
        const data = sheet.getDataRange().getValues();

        if (data.length < 2) {
          Logger.log(`ヘッダー行のみ、またはデータがないためスキップ: ${file.getName()}`);
          continue;
        }

        const headers = data[0];
        const nameColumnIndex = headers.indexOf(nameColumnHeader);

        if (nameColumnIndex === -1) {
          Logger.log(`スプレッドシート「${file.getName()}」に氏名列（ヘッダー: ${nameColumnHeader}）が見つかりませんでした。スキップします。`);
          continue;
        }

        // ヘッダー行を除いたデータ行を処理
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          if (row[nameColumnIndex] === employeeName) { // 氏名が一致する行を検索
            const evaluationData = {};
            const targetHeaders = [
              '本人から', 'マネージャから', '自己評価', 'マネージャ評価',
              '来季目標', '目標達成のためにサポートしてほしい事', 'サポート方針', '目標グレード'
            ];

            headers.forEach((header, index) => {
              if (targetHeaders.includes(header)) {
                evaluationData[header] = row[index] || '';
              }
            });
            return evaluationData; // 該当社員の自己評価データを返す
          }
        }
      }
    }
  }
  catch (e) {
    Logger.log(`自己評価シートの取得中にエラーが発生しました: ${e.message}`);
  }
  return null;
}

/**
 * 日報ログと自己評価シートを総合的に分析し、1on1ヒアリング項目を生成する。
 * 全社員を対象に実行される。
 */
function generate1on1Topics() {
  const employeeNames = getAllEmployeeNames();
  const roomIds = getChatworkTargetRoomIds();
  const managerRoomId = roomIds.manager;

  if (!managerRoomId) {
    Logger.log("マネージャーのChatworkルームIDが設定されていません。1on1ヒアリング項目通知をスキップします。");
    SpreadsheetApp.getUi().alert('エラー', 'マネージャーのChatworkルームIDが設定されていません。スクリプトプロパティを確認してください。', SpreadsheetApp.getUi().ButtonSet.OK);
    return;
  }

  if (employeeNames.length === 0) {
    Logger.log("「日報ログ」シートに社員データが見つかりませんでした。1on1ヒアリング項目生成をスキップします。");
    SpreadsheetApp.getUi().alert('情報', '「日報ログ」シートに社員データが見つかりませんでした。ヒアリング項目は生成されません。', SpreadsheetApp.getUi().ButtonSet.OK);
    return;
  }

  for (const employeeName of employeeNames) {
    Logger.log(`${employeeName}さんの1on1ヒアリング項目を生成中...`);
    const dailyReports = getDailyReportDataForEmployee(employeeName, 5); // 直近5件の日報
    const selfEvaluation = getSelfEvaluationDataForEmployee(employeeName);

    let promptDailyReports = 'データなし';
    if (dailyReports.length > 0) {
      promptDailyReports = dailyReports.map(report => 
        `状態: ${report.aiStatus}, 理由: ${report.aiReason}`
      ).join('\n');
    }

    let promptSelfEvaluation = 'データなし';
    if (selfEvaluation) {
      promptSelfEvaluation = Object.entries(selfEvaluation).map(([key, value]) => 
        `${key}: ${value}`
      ).join('\n');
    }

    const anonymousName = `提出者_${employeeName.replace(/[^a-zA-Z0-9]/g, '')}`; // 簡易的な匿名化

    const geminiPrompt = `以下の${anonymousName}さんの日報データと自己評価シートのデータを総合的に分析し、次回の1on1面談でマネージャーが${anonymousName}さんにヒアリングすべき具体的な質問やテーマを5つ提案してください。質問は部下の心情に寄り添い、具体的な行動を促す形式にしてください。提案は箇条書き形式でお願いします。

**直近の日報におけるAI評価：**
${promptDailyReports}

**自己評価シートの主要項目：**
${promptSelfEvaluation}`;

    try {
      // const geminiResponse = callGeminiApi(geminiPrompt);
      // const hearingTopics = geminiResponse.candidates[0].content.parts[0].text;
      Logger.log(`[Gemini呼び出しスキップ] ${employeeName}さんの1on1ヒアリング項目生成。ダミーデータを使用します。`);
      const hearingTopics = `[Gemini呼び出し省略] 1on1ヒアリング項目のダミーリスト\n- ダミー質問1\n- ダミー質問2\n- ダミー質問3`;

      const subject = `【1on1ヒアリング項目提案】${employeeName}さん向け`;
      const body = `[info]\n[title]${subject}[/title]\n${hearingTopics}\n[/info]`;

      sendChatworkNotification(managerRoomId, body);
      Logger.log(`${employeeName}さんの1on1ヒアリング項目をChatworkに通知しました。`);

    } catch (error) {
      Logger.log(`Gemini API呼び出しまたはChatwork通知に失敗しました（${employeeName}さん）: ${error.message}`);
      SpreadsheetApp.getUi().alert('エラー', `${employeeName}さんの1on1ヒアリング項目生成中にエラーが発生しました: ${error.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
    }
  }
  SpreadsheetApp.getUi().alert('完了', '全社員の1on1ヒアリング項目生成と通知が完了しました。', SpreadsheetApp.getUi().ButtonSet.OK);
}


