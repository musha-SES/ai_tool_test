/**
 * スプレッドシートを開いたときにカスタムメニューを追加する関数。
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('日報AIツール')
    .addItem('日報質問送信（Chatwork）', 'sendDailyReportQuestions')
    .addItem('Chatwork日報取得・分析', 'processChatworkReplies')
    .addSeparator()
    .addItem('定期実行トリガーを設定', 'createDailyTriggers')
    .addItem('全てのトリガーを削除', 'deleteTriggers')
    .addSeparator()
    .addItem('1on1ヒアリング項目生成', 'generate1on1Topics')
    .addToUi();
}

// --- トリガー管理機能 ---

/**
 * スクリプトプロパティから定期実行の時刻を取得する。
 * @returns {{questionHour: number, questionMinute: number, replyHour: number, replyMinute: number}}
 */
function getScheduledTimes() {
  const properties = PropertiesService.getScriptProperties();
  const defaults = {
    questionHour: 9,
    questionMinute: 0,
    replyHour: 18,
    replyMinute: 0
  };

  const getPropertyAsInt = (key, defaultValue) => {
    const prop = properties.getProperty(key);
    const value = parseInt(prop, 10);
    if (isNaN(value)) {
      Logger.log(`スクリプトプロパティ「${key}」が未設定または不正です。デフォルト値 (${defaultValue}) を使用します。`);
      return defaultValue;
    }
    return value;
  };

  const questionHour = getPropertyAsInt('DAILY_QUESTION_TIME_HOUR', defaults.questionHour);
  const questionMinute = getPropertyAsInt('DAILY_QUESTION_TIME_MINUTE', defaults.questionMinute);
  const replyHour = getPropertyAsInt('DAILY_REPLY_COLLECT_TIME_HOUR', defaults.replyHour);
  const replyMinute = getPropertyAsInt('DAILY_REPLY_COLLECT_TIME_MINUTE', defaults.replyMinute);

  return { questionHour, questionMinute, replyHour, replyMinute };
}

/**
 * 毎日の定期実行トリガーを作成する。
 */
function createDailyTriggers() {
  deleteTriggers();
  const { questionHour, questionMinute, replyHour, replyMinute } = getScheduledTimes();

  ScriptApp.newTrigger('sendDailyReportQuestions')
    .timeBased()
    .everyDays(1)
    .atHour(questionHour)
    .nearMinute(questionMinute)
    .create();
  Logger.log(`日報質問送信トリガーを毎日 ${questionHour}時${questionMinute}分頃に設定しました。`);

  ScriptApp.newTrigger('processChatworkReplies')
    .timeBased()
    .everyDays(1)
    .atHour(replyHour)
    .nearMinute(replyMinute)
    .create();
  Logger.log(`Chatwork日報取得・分析トリガーを毎日 ${replyHour}時${replyMinute}分頃に設定しました。`);

  ScriptApp.newTrigger('cleanUpBotQuestionLog')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.MONDAY)
    .atHour(2)
    .create();
  Logger.log(`BOT質問ログクリーンアップトリガーを毎週月曜日深夜2時に設定しました。`);

  SpreadsheetApp.getUi().alert('定期実行トリガーを設定しました。 質問送信: 毎日' + `${questionHour}時${questionMinute}分頃` + ' 返信収集: 毎日' + `${replyHour}時${replyMinute}分頃` + ' ログクリーンアップ: 毎週月曜日深夜');
}

/**
 * BOT質問ログシートをクリーンアップする。
 */
function cleanUpBotQuestionLog() {
  const logSheetName = 'BOT質問ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    Logger.log(`シート「${logSheetName}」が見つかりません。クリーンアップをスキップします。`);
    return;
  }

  const range = sheet.getDataRange();
  const values = range.getValues();
  if (values.length <= 1) {
    return;
  }

  const rowsToDelete = [];
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const status = row[3].toString();
    const timestamp = new Date(row[2]);

    if (status === '返信済み_処理成功' || ((status === '未返信' || status === '返信済み_フォーマット不正' || status.startsWith('エラー発生')) && timestamp < sevenDaysAgo)) {
      rowsToDelete.push(i + 1);
    }
  }

  rowsToDelete.sort((a, b) => b - a).forEach(rowIndex => sheet.deleteRow(rowIndex));
  Logger.log(`BOT質問ログシートのクリーンアップが完了しました。${rowsToDelete.length}件のレコードを削除しました。`);
}

/**
 * このスクリプトで設定されたすべてのトリガーを削除する。
 */
function deleteTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => ScriptApp.deleteTrigger(trigger));
  Logger.log('すべてのトリガーを削除しました。');
}

// --- Chatwork連携機能 ---

/**
 * Chatwork APIキーをスクリプトプロパティから取得する。
 */
function getChatworkApiKey() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('CHATWORK_API_KEY');
  if (!apiKey) {
    throw new Error('Chatwork API Key is not set in Script Properties.');
  }
  return apiKey;
}

/**
 * 「Chatwork設定」シートから全社員の情報をフラットな配列として取得する。
 * @returns {Array<{employeeName: string, employeeRoomId: string, managerName: string, managerRoomId: string}>}
 */
function getChatworkTargetRoomIds() {
  const sheetName = 'Chatwork設定';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
  if (!sheet) {
    Logger.log(`エラー: シート「${sheetName}」が見つかりません。`);
    return [];
  }

  const data = sheet.getDataRange().getValues();
  const header = data.shift(); // ヘッダー行を除去
  const headerMap = header.reduce((acc, col, index) => ({ ...acc, [col]: index }), {});

  const requiredColumns = ['グループ名', '氏名', 'ルームID', '役割'];
  for (const col of requiredColumns) {
    if (headerMap[col] === undefined) {
      Logger.log(`エラー: シート「${sheetName}」に必要な列「${col}」がありません。`);
      return [];
    }
  }

  const managers = {};
  const employees = [];

  data.forEach(row => {
    const group = row[headerMap['グループ名']];
    const name = row[headerMap['氏名']];
    const roomId = row[headerMap['ルームID']].toString();
    const role = row[headerMap['役割']];

    if (!group || !name || !roomId || !role) return; // 空の行はスキップ

    if (role.toLowerCase() === 'manager') {
      managers[group] = { name, roomId };
    } else if (role.toLowerCase() === 'employee') {
      employees.push({ group, name, roomId });
    }
  });

  const flatEmployeeList = employees.map(emp => {
    const manager = managers[emp.group];
    if (!manager) {
      Logger.log(`警告: 社員「${emp.name}」のグループ「${emp.group}」に対応するマネージャーが見つかりません。`);
      return null;
    }
    return {
      employeeName: emp.name,
      employeeRoomId: emp.roomId,
      managerName: manager.name,
      managerRoomId: manager.roomId
    };
  }).filter(Boolean); // nullを除外

  return flatEmployeeList;
}

/**
 * 全ての部下に日報提出を促す質問をChatworkで送信する。
 */
function sendDailyReportQuestions() {
  const employeeList = getChatworkTargetRoomIds();
  const pendingQuestions = getPendingQuestionMessages();

  employeeList.forEach(employee => {
    const { employeeName, employeeRoomId } = employee;

    const existingPending = pendingQuestions.find(q =>
      q.roomId === employeeRoomId &&
      (q.status === '未返信' || q.status === '返信済み_フォーマット不正' || q.status.startsWith('エラー発生'))
    );

    if (existingPending) {
      Logger.log(`${employeeName}さん（ルームID: ${employeeRoomId}）には未処理の日報が存在するため、質問送信をスキップしました。ステータス: ${existingPending.status}`);
      return;
    }

    const message = `[To:${employeeRoomId}] ${employeeName}さん
おはようございます！
本日の日報を以下のフォーマットでご返信ください。

#日報
業務内容：
気分：(良い/普通/少し悪い/悪い)
困っていること：`;
    try {
      const response = sendChatworkNotification(employeeRoomId, message);
      const messageId = response.message_id.toString();
      logQuestionMessageId(employeeRoomId, messageId, new Date(), '未返信');
      Logger.log(`${employeeName}さん (Room ID: ${employeeRoomId}) への質問送信に成功しました。メッセージID: ${messageId}`);
    } catch (e) {
      Logger.log(`${employeeName}さん (Room ID: ${employeeRoomId}) への質問送信に失敗しました: ${e.message}`);
    }
  });
}

/**
 * Chatworkの返信を収集し、日報として解析・評価する。
 */
function processChatworkReplies() {
  const employeeList = getChatworkTargetRoomIds();
  const botAccountId = getBotChatworkAccountId();
  const pendingQuestions = getPendingQuestionMessages();

  employeeList.forEach(employee => {
    const { employeeName, employeeRoomId, managerName, managerRoomId } = employee;

    const questionsForThisRoom = pendingQuestions.filter(q =>
      q.roomId === employeeRoomId && q.status !== '返信済み_処理成功'
    );

    if (questionsForThisRoom.length === 0) {
      return;
    }
    
    const lockedQuestion = questionsForThisRoom.find(q => q.status === '返信済み_フォーマット不正' || q.status.startsWith('エラー発生'));
    if (lockedQuestion) {
        Logger.log(`${employeeName}さん (Room ID: ${employeeRoomId}) の日報はロックステータス（${lockedQuestion.status}）のためスキップしました。`);
        return;
    }

    try {
      const messages = getChatworkMessages(employeeRoomId, 50);
      let processedThisRoom = false;

      for (let i = messages.length - 1; i >= 0; i--) {
        const msg = messages[i];
        if (msg.account_id && msg.account_id.toString() === botAccountId) continue;

        const replyMatch = msg.body.match(/\[rp aid=(\d+) to=(\d+)-(\d+)\]/);
        if (!replyMatch) continue;

        const repliedToMessageId = replyMatch[3];
        const matchedQuestion = questionsForThisRoom.find(q => q.messageId === repliedToMessageId);

        if (matchedQuestion) {
          if (msg.body.includes('#日報')) {
            const reportData = parseReportFromMessage(employeeName, msg.body);
            const validationResult = validateDailyReport(reportData);

            if (validationResult.isValid) {
              try {
                assessAndNotify(reportData, managerName, managerRoomId);
                updateQuestionStatus(employeeRoomId, matchedQuestion.messageId, '返信済み_処理成功');
              } catch (e) {
                Logger.log(`日報処理中にエラーが発生しました: ${e.message}`);
                updateQuestionStatus(employeeRoomId, matchedQuestion.messageId, 'エラー発生_その他', e.message);
              }
            } else {
              Logger.log(`${employeeName}さんの日報はフォーマット不正です。詳細: ${validationResult.message}`);
              updateQuestionStatus(employeeRoomId, matchedQuestion.messageId, '返信済み_フォーマット不正', validationResult.message);
            }
          }
          processedThisRoom = true;
          break;
        }
      }
    } catch (e) {
      Logger.log(`${employeeName}さん (Room ID: ${employeeRoomId}) のメッセージ処理中にエラー: ${e.message}`);
    }
  });
}

/**
 * Chatwork APIを呼び出してメッセージを取得する。
 */
function getChatworkMessages(roomId, count) {
  const apiKey = getChatworkApiKey();
  const url = `https://api.chatwork.com/v2/rooms/${roomId}/messages?force=1`;
  const options = {
    method: 'get',
    headers: { 'X-ChatWorkToken': apiKey },
    muteHttpExceptions: true
  };
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const responseText = response.getContentText();
  if (responseCode === 200) {
    return JSON.parse(responseText).slice(-count);
  }
  throw new Error(`Chatwork APIからのメッセージ取得に失敗。Status: ${responseCode}, Response: ${responseText}`);
}

/**
 * Chatworkメッセージから日報データを抽出する。
 */
function parseReportFromMessage(name, messageBody) {
  const workContentMatch = messageBody.match(/業務内容：\s*([\s\S]*?)(?=\n*気分：|\n*困っていること：|$)/);
  const moodMatch = messageBody.match(/気分：\s*([\s\S]*?)(?=\n*困っていること：|$)/);
  const problemsMatch = messageBody.match(/困っていること：\s*([\s\S]*)/);
  return {
    date: new Date().toLocaleString('ja-JP'),
    name: name,
    workContent: workContentMatch ? workContentMatch[1].trim() : 'N/A',
    mood: moodMatch ? moodMatch[1].trim() : 'N/A',
    problems: problemsMatch ? problemsMatch[1].trim() : '特になし'
  };
}

/**
 * 日報データのバリデーションを行う。
 */
function validateDailyReport(reportData) {
  const moods = ['良い', '普通', '少し悪い', '悪い'];
  if (!reportData.name || reportData.name.trim() === 'N/A') {
    return { isValid: false, message: '氏名が空です。' };
  }
  if (!reportData.workContent || reportData.workContent.trim() === 'N/A') {
    return { isValid: false, message: '業務内容が空です。' };
  }
  if (!reportData.mood || !moods.includes(reportData.mood.trim())) {
    return { isValid: false, message: `気分に不正な値「${reportData.mood}」が入力されています。` };
  }
  return { isValid: true, message: '' };
}

// --- Gemini API & 通知機能 ---

/**
 * 日報データを評価し、必要に応じて通知する。
 * @param {Object} reportData 日報データ
 * @param {string} managerName マネージャー名
 * @param {string} managerRoomId マネージャーのルームID
 */
function assessAndNotify(reportData, managerName, managerRoomId) {
  const geminiPrompt = `以下の日報の内容を分析し、提出者の現在の心理状態や業務の調子について、5段階（非常に良い、良い、普通、少し悪い、危険）で評価してください。\n**特に「今日の気分」が悪い場合や、「困っていること」にネガティブな兆候が見られる場合は「危険」と判断し、その理由も簡潔に述べてください。**\n氏名は匿名化し、「提出者」として言及してください。\n\n業務内容：${reportData.workContent}\n気分：${reportData.mood}\n困っていること：${reportData.problems}\n\n結果はJSON形式で返してください。例: { "status": "危険", "reason": "具体例：今日の気分が悪いと申告しており、困っている内容にXXとあるため。" }`;
  let geminiStatus = '不明';
  let geminiReason = 'Gemini APIからの応答がありませんでした。';

  try {
    const geminiResponse = callGeminiApi(geminiPrompt);
    const rawGeminiText = geminiResponse.candidates[0].content.parts[0].text;
    const jsonMatch = rawGeminiText.match(/\{([\s\S]*?)\}/);
    if (jsonMatch && jsonMatch[0]) {
      const parsedResponse = JSON.parse(jsonMatch[0]);
      geminiStatus = parsedResponse.status;
      geminiReason = parsedResponse.reason;
    } else {
      throw new Error('Gemini API response did not contain a valid JSON object.');
    }
  } catch (error) {
    Logger.log('Gemini API呼び出しまたは応答解析に失敗: ' + error.message);
  }

  if (geminiStatus === '危険' || geminiStatus === '少し悪い') {
    if (!managerRoomId) {
      Logger.log("マネージャーのChatworkルームIDが不明なため、通知をスキップします。");
    } else {
      const subject = `【注意】日報から社員の調子に懸念 - ${reportData.name}`;
      const body = `[info][title]${subject}[/title]提出者：${reportData.name}\n日付：${reportData.date}\nGemini AIによる評価：${geminiStatus}\n理由：${geminiReason}\n[hr]▼ 日報抜粋\n今日の気分：${reportData.mood}\n困っていること：${reportData.problems}\n[hr]詳細については、スプレッドシートをご確認ください。[/info]`;
      try {
        sendChatworkNotification(managerRoomId, body);
        Logger.log('Chatworkへの注意通知が正常に送信されました。');
      } catch (e) {
        Logger.log('Chatworkへの注意通知の送信に失敗しました: ' + e.message);
      }
    }
  }
  
  try {
    logReportToSheet(reportData, geminiStatus, geminiReason, managerName);
  } catch (e) {
    Logger.log('スプレッドシートへの日報ログ記録に失敗しました: ' + e.message);
  }
}

/**
 * 日報データをスプレッドシートに記録する。
 * @param {Object} reportData 日報データ
 * @param {string} status AIによる評価状態
 * @param {string} reason AIによる評価理由
 * @param {string} managerName マネージャー名
 */
function logReportToSheet(reportData, status, reason, managerName) {
  const logSheetName = '日報ログ';
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(logSheetName);
  if (!sheet) {
    throw new Error(`シート「${logSheetName}」が見つかりません。`);
  }
  sheet.appendRow([
    new Date(),           // タイムスタンプ
    managerName || 'N/A', // マネージャー名
    reportData.name,      // 氏名
    reportData.date,      // 日報日付
    reportData.workContent,
    reportData.mood,
    reportData.problems,
    status,
    reason
  ]);
  Logger.log(`日報データを「${logSheetName}」シートに記録しました。`);
}

/**
 * Chatworkにメッセージを送信する汎用関数。
 */
function sendChatworkNotification(roomId, message) {
  try {
    const apiKey = getChatworkApiKey();
    const url = `https://api.chatwork.com/v2/rooms/${roomId}/messages`;
    const payload = { body: message, self_unread: 1 };
    const options = {
      method: 'post',
      headers: { 'X-ChatWorkToken': apiKey },
      contentType: 'application/x-www-form-urlencoded',
      payload: Object.keys(payload).map(key => `${key}=${encodeURIComponent(payload[key])}`).join('&'),
      muteHttpExceptions: true
    };
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    if (responseCode !== 200) {
      throw new Error(`Chatwork API送信失敗。Status: ${responseCode}, Response: ${responseText}`);
    }
    return JSON.parse(responseText);
  } catch (e) {
    Logger.log(`sendChatworkNotificationでエラー: ${e.message}`);
    throw e;
  }
}

const CHATWORK_BOT_ACCOUNT_ID_KEY = 'CHATWORK_BOT_ACCOUNT_ID';

/**
 * BOT自身のChatworkアカウントIDを取得する。
 */
function getBotChatworkAccountId() {
  const properties = PropertiesService.getScriptProperties();
  let botAccountId = properties.getProperty(CHATWORK_BOT_ACCOUNT_ID_KEY);
  if (botAccountId) return botAccountId;

  try {
    const apiKey = getChatworkApiKey();
    const url = 'https://api.chatwork.com/v2/me';
    const options = { method: 'get', headers: { 'X-ChatWorkToken': apiKey }, muteHttpExceptions: true };
    const response = UrlFetchApp.fetch(url, options);
    if (response.getResponseCode() !== 200) {
      throw new Error(`Chatwork API (me) 取得失敗: ${response.getContentText()}`);
    }
    const me = JSON.parse(response.getContentText());
    botAccountId = me.account_id.toString();
    properties.setProperty(CHATWORK_BOT_ACCOUNT_ID_KEY, botAccountId);
    return botAccountId;
  } catch (e) {
    Logger.log(`BOTアカウントIDの取得に失敗: ${e.message}`);
    throw e;
  }
}

/**
 * 送信した質問メッセージのIDをBOT質問ログシートに記録する。
 */
function logQuestionMessageId(roomId, messageId, timestamp, status) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('BOT質問ログ');
  if (!sheet) throw new Error('シート「BOT質問ログ」が見つかりません。');
  sheet.appendRow([roomId, messageId, timestamp, status, '']);
  Logger.log(`質問メッセージID ${messageId} をルーム ${roomId} に記録しました。`);
}

/**
 * BOT質問ログシートから未処理の質問メッセージIDを読み込む。
 */
function getPendingQuestionMessages() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('BOT質問ログ');
  if (!sheet) return [];
  const values = sheet.getDataRange().getValues();
  values.shift(); // ヘッダーを除去
  return values.map((row, index) => ({
    rowIndex: index + 2,
    roomId: row[0].toString(),
    messageId: row[1].toString(),
    timestamp: new Date(row[2]),
    status: row[3].toString(),
    errorDetail: row[4] ? row[4].toString() : ''
  }));
}

/**
 * BOT質問ログシートの質問メッセージのステータスを更新する。
 */
function updateQuestionStatus(roomId, messageId, newStatus, errorDetail = '') {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('BOT質問ログ');
  if (!sheet) return;
  const values = sheet.getDataRange().getValues();
  for (let i = 1; i < values.length; i++) {
    if (values[i][0].toString() === roomId && values[i][1].toString() === messageId) {
      sheet.getRange(i + 1, 4).setValue(newStatus);
      sheet.getRange(i + 1, 5).setValue(errorDetail);
      Logger.log(`質問メッセージID ${messageId} のステータスを ${newStatus} に更新しました。`);
      return;
    }
  }
}

/**
 * Gemini APIキーをスクリプトプロパティから取得する。
 */
function getGeminiApiKey() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  if (!apiKey) throw new Error('Gemini API Key is not set in Script Properties.');
  return apiKey;
}

/**
 * Gemini APIを呼び出し、応答をJSON形式で返す。
 */
function callGeminiApi(prompt) {
  try {
    const apiKey = getGeminiApiKey();
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
    const requestBody = { contents: [{ parts: [{ text: prompt }] }] };
    const options = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(requestBody),
      muteHttpExceptions: true,
    };
    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    if (responseCode === 200) {
      return JSON.parse(responseText);
    }
    throw new Error(`Gemini API呼び出し失敗。HTTP ${responseCode}, 応答: ${responseText}`);
  } catch (e) {
    throw e;
  }
}

// --- 1on1ヒアリング項目生成機能 ---

/**
 * 指定された社員の過去の日報データを取得する。
 */
function getDailyReportDataForEmployee(employeeName, limit = 5) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('日報ログ');
  if (!sheet) return [];
  const values = sheet.getDataRange().getValues();
  values.shift();

  const employeeReports = values.filter(row => row[2] && row[2].toString().trim().toLowerCase() === employeeName.trim().toLowerCase()) // C列（氏名）でフィルタ
    .slice(-limit) // 直近N件
    .map(row => ({
      workContent: row[4], // E列
      problems: row[6],    // G列
      aiReason: row[8]     // I列
    }));
  
  Logger.log(`${employeeName}さんの日報ログデータを${employeeReports.length}件取得しました。`);
  return employeeReports;
}

const MAX_PROMPT_TEXT_LENGTH = 150;

function truncateText(text, maxLength) {
  if (typeof text !== 'string' || !text) return '';
  return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

/**
 * 1on1ヒアリング項目を生成する。
 */
function generate1on1Topics() {
  const ui = SpreadsheetApp.getUi();
  const targetEmployeeName = PropertiesService.getScriptProperties().getProperty('TARGET_EMPLOYEE_NAME_FOR_1ON1');

  if (!targetEmployeeName) {
    const errorMessage = 'スクリプトプロパティ「TARGET_EMPLOYEE_NAME_FOR_1ON1」が設定されていません。';
    Logger.log(errorMessage);
    ui.alert('設定エラー', errorMessage, ui.ButtonSet.OK);
    return;
  }

  const employeeList = getChatworkTargetRoomIds();
  const targetEmployee = employeeList.find(emp => emp.employeeName === targetEmployeeName);

  if (!targetEmployee) {
      const errorMessage = `「Chatwork設定」シートに「${targetEmployeeName}」さんが見つかりません。`;
      Logger.log(errorMessage);
      ui.alert('設定エラー', errorMessage, ui.ButtonSet.OK);
      return;
  }
  
  const { managerRoomId } = targetEmployee;

  if (!managerRoomId) {
      Logger.log(`マネージャーのChatworkルームIDが設定されていません（${targetEmployeeName}さん）。`);
      ui.alert('エラー', 'マネージャーのルームIDが設定されていません。', ui.ButtonSet.OK);
      return;
  }

  const dailyReports = getDailyReportDataForEmployee(targetEmployeeName, 5);
  if (dailyReports.length === 0) {
    const infoMessage = `「${targetEmployeeName}」さんの日報ログデータが見つかりませんでした。`;
    Logger.log(infoMessage);
    ui.alert('情報', infoMessage, ui.ButtonSet.OK);
    return;
  }

  const promptDailyReports = dailyReports.map(r => `業務内容: ${truncateText(r.workContent, MAX_PROMPT_TEXT_LENGTH)}, 困っていること: ${truncateText(r.problems, MAX_PROMPT_TEXT_LENGTH)}, AI評価理由: ${truncateText(r.aiReason, MAX_PROMPT_TEXT_LENGTH)}`).join('\n');
  const geminiPrompt = `以下の対象者さんの直近の日報データを総合的に分析し、次回の1on1面談でマネージャーがヒアリングすべき具体的な質問やテーマを5つ提案してください。特に、コンディションの傾向、過去の懸念点、困っている内容に焦点を当て、部下の心情に寄り添う具体的な質問を箇条書きでお願いします。\n\n**直近の日報データ：**\n${promptDailyReports}`;

  try {
    const geminiResponse = callGeminiApi(geminiPrompt);
    const hearingTopics = geminiResponse.candidates[0].content.parts[0].text;
    const subject = `【1on1ヒアリング項目提案】${targetEmployeeName}さん向け`;
    const body = `[info][title]${subject}[/title]\n${hearingTopics}[/info]`;

    sendChatworkNotification(managerRoomId, body);
    Logger.log(`${targetEmployeeName}さんの1on1ヒアリング項目をChatworkに通知しました。`);
    ui.alert('完了', `${targetEmployeeName}さんの1on1ヒアリング項目生成と通知が完了しました。`, ui.ButtonSet.OK);
  } catch (error) {
    const errorMessage = `1on1ヒアリング項目生成中にエラーが発生しました: ${error.message}`;
    Logger.log(errorMessage);
    ui.alert('エラー', errorMessage, ui.ButtonSet.OK);
  }
}